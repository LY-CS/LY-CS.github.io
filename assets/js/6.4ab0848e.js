(window.webpackJsonp=window.webpackJsonp||[]).push([[6],{207:function(a,t,s){"use strict";s.r(t);var v=s(0),e=Object(v.a)({},(function(){var a=this,t=a.$createElement,s=a._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("h1",{attrs:{id:"csharp基础·命名规则"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#csharp基础·命名规则"}},[a._v("#")]),a._v(" CSharp基础·命名规则")]),a._v(" "),s("h2",{attrs:{id:"命名规范·类"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#命名规范·类"}},[a._v("#")]),a._v(" 命名规范·类")]),a._v(" "),s("p",[a._v("1.使用Pascal规则命名类名，即首字母要大写。")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("#示例\nClass Test\n{\n    ···\n}\n")])])]),s("p",[a._v("2.使用能够反映类功能的名词或名词短语命名类。")]),a._v(" "),s("p",[a._v("3.不要使用“I”、“C”、“_”等特定含义前缀。")]),a._v(" "),s("p",[a._v("4.自定义异常类应以Exception结尾。")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("#示例\nClass TestException\n{\n    ···\n}\n")])])]),s("p",[a._v("5.文件名要能反映类的内容，最好是和类同名。")]),a._v(" "),s("h2",{attrs:{id:"命名规范·类字段-类成员"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#命名规范·类字段-类成员"}},[a._v("#")]),a._v(" 命名规范·类字段(类成员)")]),a._v(" "),s("p",[a._v("1.用camel规则来命名类成员变量名称，即首单词（或单词缩写）小写。")]),a._v(" "),s("p",[a._v("2.类字段变量名前可加“_”前缀。")]),a._v(" "),s("p",[a._v("3.坚决禁止在普通变量前加“m_”（这是VC老命名规则）。")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("#示例\nClass Test\n{\n    privatestring myName;\n    privatestring _myCoCo;\n    ...\n}\n")])])]),s("h2",{attrs:{id:"命名规范·方法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#命名规范·方法"}},[a._v("#")]),a._v(" 命名规范·方法")]),a._v(" "),s("p",[a._v("1.方法名采用Pascal规则，第一个字符要大写。")]),a._v(" "),s("p",[a._v("2.方法名应使用动词或动词短语。")]),a._v(" "),s("p",[a._v("3.类中访问修饰符或功能相同的方法应该放在一起， 且公共或实现接口的方法在前。")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("#示例\nClass Test\n{\n      publicvoid GetData(...)\n      {\n        ···\n      }\n      privatevoid GetName(...)\n      {\n        ···\n      }\n      privatestatic void GetCount(...)\n      { \n        ···\n      }\n}\n")])])]),s("h2",{attrs:{id:"命名规范·属性"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#命名规范·属性"}},[a._v("#")]),a._v(" 命名规范·属性")]),a._v(" "),s("p",[a._v("1.使用名词定义属性，属性使用Pascal规则，首字符大写")]),a._v(" "),s("p",[a._v("2.属性和相应字段名称要关联， 可以使用“重构”菜单来生成属性。")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("#示例\nClass Test\n{\n   private string myName;\n   public string MyName\n   {\n      set\n      {\n         myName = Value;\n      }\n      get\n      {\n         return myName;\n      }\n   }\n}\n")])])]),s("h2",{attrs:{id:"命名规范·参数"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#命名规范·参数"}},[a._v("#")]),a._v(" 命名规范·参数")]),a._v(" "),s("p",[a._v("1.参数采用camel规则命名，且首字符小写。")]),a._v(" "),s("p",[a._v("2.使用描述性参数名称，参数名称应当具有最够的说明性。")]),a._v(" "),s("p",[a._v("3.不要给参数加匈牙利语类型表示法的前缀。")]),a._v(" "),s("p",[a._v("4.检查方法所有输入参数的有效性。")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("#示例\n      ClassTest\n      {\n         public void GetData(string name,string strFlag)\n         {\n            ...\n         }\n      }\n")])])]),s("h2",{attrs:{id:"命名规范·常量"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#命名规范·常量"}},[a._v("#")]),a._v(" 命名规范·常量")]),a._v(" "),s("p",[a._v("1.只读常量使用Pascal命名规则，即首字母大写。")]),a._v(" "),s("p",[a._v("2.枚举名使用Pascal规则命名，枚举成员本质属于常量，命名规则同上。")]),a._v(" "),s("p",[a._v("3.枚举值从小到大顺序定义。")]),a._v(" "),s("p",[a._v("4.静态字段或属性采用Pascal规则，即首字符大写。")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("#示例\n      ClassTest\n      {\n         public const double Pi = 3.14159365753;\n         private readonly double Pai = 3.14159365753;\n        ···\n      }\n")])])]),s("h2",{attrs:{id:"命名规范·接口"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#命名规范·接口"}},[a._v("#")]),a._v(" 命名规范·接口")]),a._v(" "),s("p",[a._v("1.接口定义使用Pascal规则，且必须以大写“I”开头。")]),a._v(" "),s("p",[a._v("2.接口名称要有意义，中间不要有下划线“_”等字符。")]),a._v(" "),s("p",[a._v("3.如果类实现了接口，名称尽量和接口相同， 只是省掉“I”字符。")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("#示例：注意这里的接口修饰符只能用public和internal\n   interfaceITest\n   {\n      ···\n   }\n")])])]),s("h2",{attrs:{id:"命名规范·事件"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#命名规范·事件"}},[a._v("#")]),a._v(" 命名规范·事件")]),a._v(" "),s("p",[a._v("1.委托名称采用Pascal规则，即首字符大写。")]),a._v(" "),s("p",[a._v("2.定义事件的委托要使用EventHandler后缀，且包括sender和e两个参数。")]),a._v(" "),s("p",[a._v("3.事件用到的参数，名称要带EventArgs后缀。")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("#示例\n   ClassTest\n   {\n      private delegate void DoTask();\n      private event DoTask DoTaskEventHandler;\n      private event DoTask DoTaskEventHandler(Object sender,EventArgse);\n      private event DoTaskDoTaskEventHandler2(string   strEventArgs)\n      {\n         ...\n      }\n      ...\n   }\n")])])]),s("p"),a._v(" "),s("h2",{attrs:{id:"命名规范·命名空间"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#命名规范·命名空间"}},[a._v("#")]),a._v(" 命名规范·命名空间")]),a._v(" "),s("p",[a._v("1.命名空间名称采用Pascal规则，且首字符大写。")]),a._v(" "),s("p",[a._v("2.命名空间名称尽量反映其内容所提供的整体功能。")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("#示例\nnamespace MyTest\n{\n      ClassTest\n    {\n       ...\n    }\n    ...\n}\n")])])]),s("h2",{attrs:{id:"注释规范·文件头部注释"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#注释规范·文件头部注释"}},[a._v("#")]),a._v(" 注释规范·文件头部注释")]),a._v(" "),s("p",[a._v("1.文件都包含文件头， 要说明文件名、作者、创建时间、变更记录。")]),a._v(" "),s("p",[a._v("2.推荐采用.NET形式书写头部注释。(待考查)")]),a._v(" "),s("h2",{attrs:{id:"注释规范·类及其成员注释"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#注释规范·类及其成员注释"}},[a._v("#")]),a._v(" 注释规范·类及其成员注释")]),a._v(" "),s("p",[a._v(".1对方法和类使用“///”三斜线注释。")]),a._v(" "),s("p",[a._v("2.代码行文注释采用“//”和“/**/”进行，应该尽量说明问题。")]),a._v(" "),s("h2",{attrs:{id:"行文规范·缩写规范"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#行文规范·缩写规范"}},[a._v("#")]),a._v(" 行文规范·缩写规范")]),a._v(" "),s("p",[a._v("1.标识符应当直观可望文知意，不提倡使用任何缩写。")]),a._v(" "),s("p",[a._v("2.字符串变量推荐是用“str”或“s”开头，采用string.Empty来初始化。")]),a._v(" "),s("p",[a._v("3.普通对象可以以“obj”开头。")]),a._v(" "),s("p",[a._v("4.缩写可自行定义，一般取单词的前/后字符组成，以含义直观为准则。")]),a._v(" "),s("p",[a._v("5.一般情况下不要让缩写破坏标识符的含义。")]),a._v(" "),s("h2",{attrs:{id:"行文规范·排版"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#行文规范·排版"}},[a._v("#")]),a._v(" 行文规范·排版")]),a._v(" "),s("p",[a._v("1.每行语句至少占一行，如果语句过长（超过一屏），则该语句断为两行显示。")]),a._v(" "),s("p",[a._v("2.把相似的内容放在一起，比如字段、属性、方法、事件等，使用“#region--#endregion”命令分组。")]),a._v(" "),s("p",[a._v("3.多个程序元素进行对等操作时， 操作符之前、之后或者前后都要加空格。")]),a._v(" "),s("p",[a._v("4.每个方法的源程序行数原则上应该少于200行。(如果超过过多，则需要另写一方法)")]),a._v(" "),s("p",[a._v("5.语句嵌套层次不得超过3层。")]),a._v(" "),s("p",[a._v("6.避免相同的代码段在多个地方出现。(尽量避免代码重复，能复用则复用)")]),a._v(" "),s("h2",{attrs:{id:"行文规范·语句结构"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#行文规范·语句结构"}},[a._v("#")]),a._v(" 行文规范·语句结构")]),a._v(" "),s("p",[a._v("1.如果使用了异常结构，一定要处理异常， 一般是要写日志文件。")]),a._v(" "),s("p",[a._v("2.分支语句不应该使用复杂长条件， 应该将长条件封装成方法。")]),a._v(" "),s("p",[a._v("3.switch语句，case后面必须接break。")]),a._v(" "),s("p",[a._v("4.禁止使用goto语句进行跳转。")]),a._v(" "),s("p",[a._v("5.行文中严禁出现“魔数”，特定含义的常数必须定义成枚举或常量。")]),a._v(" "),s("p",[a._v("6.不同类型的操作符混合使用时，使用括号给出优先级。")]),a._v(" "),s("p",[a._v("7.不允许使用复杂的操作符组合等。")]),a._v(" "),s("p",[a._v("8.循环、判断语句的程序块部分用花括号括起来， 即使只有一条语句。(return;待议)")]),a._v(" "),s("p",[a._v("9.在switch语句中总是要有default字句，建议使用断言。")]),a._v(" "),s("p",[a._v("10.每个类和方法完成单一的功能，不设计多用途面面俱到的类或方法。")]),a._v(" "),s("p",[a._v("11.严禁使用未经初始化的变量，变量通常使用构造方法来初始。")]),a._v(" "),s("h2",{attrs:{id:"行文规范·代码缩进"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#行文规范·代码缩进"}},[a._v("#")]),a._v(" 行文规范·代码缩进")]),a._v(" "),s("p",[a._v("1.碰到大括号要换行。")]),a._v(" "),s("p",[a._v("2.不允许使用Java中的括号换行规范。")]),a._v(" "),s("h2",{attrs:{id:"行文规范·大小写"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#行文规范·大小写"}},[a._v("#")]),a._v(" 行文规范·大小写")]),a._v(" "),s("p",[a._v("1.不要创建名称相同，但大小写区别的任何元素。")]),a._v(" "),s("p",[a._v("2.应当大写仅有两个字符的缩写。(如果只有两个字符，则都大写)")]),a._v(" "),s("p",[a._v("3.不要把易混淆的数字和字符放在一起。")]),a._v(" "),s("p",[a._v("4.使用英文命名标识符。")]),a._v(" "),s("h2",{attrs:{id:"行文规范·重名规范"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#行文规范·重名规范"}},[a._v("#")]),a._v(" 行文规范·重名规范")]),a._v(" "),s("p",[a._v("1.不允许变量名、类名、属性名、 方法名等与系统标识符重名。（系统标识符见附表）")]),a._v(" "),s("h2",{attrs:{id:"行文规范·sql编码规范"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#行文规范·sql编码规范"}},[a._v("#")]),a._v(" 行文规范·SQL编码规范")]),a._v(" "),s("p",[a._v("1.SQL语句全部大写。")]),a._v(" "),s("p",[a._v("2.对较为复杂的SQL语句加上注释，说明其功能。")]),a._v(" "),s("p",[a._v("3.连接符OR、IN、AND、以及=、<=、>=等前后加空格。")]),a._v(" "),s("p",[a._v("4.使用明确的列代替 SELECT *。")]),a._v(" "),s("h2",{attrs:{id:"行文规范·软件架构"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#行文规范·软件架构"}},[a._v("#")]),a._v(" 行文规范·软件架构")]),a._v(" "),s("p",[a._v("1.数据库中每一张表对应一个实体类/数据传输对象（DTO）。")]),a._v(" "),s("p",[a._v("2.实体类名称使用表名，也可带有Dto后缀。")]),a._v(" "),s("p",[a._v("3.三层架构应当合理使用，不应生搬硬套。")]),a._v(" "),s("h2",{attrs:{id:"行文规范·系统"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#行文规范·系统"}},[a._v("#")]),a._v(" 行文规范·系统")]),a._v(" "),s("p",[a._v("1.在我国内不建议随便使用设计模式等代码模式，因为并不流行。")]),a._v(" "),s("p",[a._v("2.系统输入、资源操作（如内存分配、文件及目录操作）、网络操作（如通信、调用等）、任务间的操作（如通信、调用等）时必须进行错误、超时、或则异常处理。")]),a._v(" "),s("p",[a._v("3.模块的编写应有完善的测试方面的考虑。")]),a._v(" "),s("hr"),a._v(" "),s("p",[a._v("参考文献：")]),a._v(" "),s("p",[a._v("·https://blog.csdn.net/chenhongwu666/article/details/35354247")])])}),[],!1,null,null,null);t.default=e.exports}}]);