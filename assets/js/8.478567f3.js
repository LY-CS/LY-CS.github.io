(window.webpackJsonp=window.webpackJsonp||[]).push([[8],{206:function(n,e,s){"use strict";s.r(e);var a=s(0),i=Object(a.a)({},(function(){var n=this,e=n.$createElement,s=n._self._c||e;return s("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[s("h1",{attrs:{id:"csharp基础·接口-虚方法-抽象类"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#csharp基础·接口-虚方法-抽象类"}},[n._v("#")]),n._v(" CSharp基础·接口&虚方法&抽象类")]),n._v(" "),s("p",[n._v("多态：让一个对象能够变出多种状态（类型），使用父类类型调用子类中实现的方法。")]),n._v(" "),s("p",[n._v("实现多态的手段：抽象类、虚方法、接口")]),n._v(" "),s("h2",{attrs:{id:"csharp基础·抽象类"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#csharp基础·抽象类"}},[n._v("#")]),n._v(" CSharp基础·抽象类:")]),n._v(" "),s("p",[n._v("1、抽象方法只能出现在抽象类中，但是抽象类中可以包含普通方法（普通方法可以由非抽象类的子类调用）。")]),n._v(" "),s("p",[n._v("2、在父类中定义的抽象方法不能实现（也就是没有方法体，定义的时候去掉大括号{}）。")]),n._v(" "),s("p",[n._v("例如：")]),n._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v('public abstract class Function{\n    public void A(){\n        Console.WriteLine ("A方法是普通方法");\n    }\n    public abstract void B(); // 没有方法体 只有方法名定义\n}\n')])])]),s("p",[n._v("3、抽象类不能实例化（也就是不能new出来）。")]),n._v(" "),s("p",[n._v("4、抽象类与抽象方法需要添加abstract关键字（如：public abstract Class Person{}，public abstract void Test（）；）。")]),n._v(" "),s("p",[n._v("5、子类实现父类的抽象方法时，需要添加override关键字。")]),n._v(" "),s("p",[n._v("6、如果抽象类的子类不是抽象类，那么子类中必须重写父类抽象类的所有抽象方法。")]),n._v(" "),s("p",[n._v("抽象类实例")]),n._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v('using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace _抽象类\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            MobileDisk md = new MobileDisk();\n            MP3 mp3 = new MP3();\n            UDisk u = new UDisk();\n\n            Computer cpu = new Computer();\n            cpu.CpuRead(md);\n            cpu.CpuWrite(md);\n            Console.ReadKey();\n\n        }\n    }\n    abstract class MobileStorage\n    {\n        public abstract void Read();\n        public abstract void Write();\n    }\n    class MobileDisk:MobileStorage\n    {\n        public override void Read()\n        {\n            Console.WriteLine("移动硬盘在读取数据");\n        }\n        public override void Write()\n        {\n            Console.WriteLine("移动硬盘在写入数据");\n        }\n    }\n    class UDisk : MobileStorage\n    {\n        public override void Read()\n        {\n            Console.WriteLine("U盘在读取数据");\n        }\n        public override void Write()\n        {\n            Console.WriteLine("U硬盘在写入数据");\n        }\n    }\n    class MP3 : MobileStorage\n    {\n        public override void Read()\n        {\n            Console.WriteLine("mp3在读取数据");\n        }\n        public override void Write()\n        {\n            Console.WriteLine("mp3在写入数据");\n        }\n        public void PlayMusic()\n        {\n            Console.WriteLine("mp3可以自己播放音乐");\n        }\n    }\n\n    class Computer\n    {\n        //传递的虽然是父类，但是由于子类都已经重写了父类的方法，所以可以在实际调用的时候传递子类\n        public void CpuRead(MobileStorage ms)\n        {\n            ms.Read();\n        }\n        public void CpuWrite(MobileStorage ms)\n        {\n            ms.Write();\n        }\n    }\n}\n\n')])])]),s("h2",{attrs:{id:"csharp基础·虚方法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#csharp基础·虚方法"}},[n._v("#")]),n._v(" CSharp基础·虚方法")]),n._v(" "),s("p",[n._v("方法替换：（这只是方法的替换 并非是虚方法）")]),n._v(" "),s("p",[n._v("子类继承父类之后，可以隐藏父类中的方法，在子类中重新实现（使用关键词new）")]),n._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v('public class Person{\n    public void A()\n    {\n        Console.WriteLine ("A方法是父类方法");\n    }\n}\n\npublic class Teacher:Person{\n    public new void  A (){//这里使用new关键词将父类的A方法替换为子类的A方法\n    Console.WriteLine ("A方法是子类方法");\n    }\n}\n')])])]),s("p",[n._v("举个栗子：")]),n._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("        Person p1 = new Person ();\n        p1.A ();// 如果等号前后定义的类型一致，那么这里的A方法为父类的方法\n\n        Teacher t1 = new Teacher ();\n        t1.A ();// 如果等号前后定义的类型一致，那么这里的A方法为子类的方法\n\n        Person p2 = new Teacher ();\n        p2.A ();// 如果使用父类类型变量接收子类类型的对象，那么此时方法为父类的方法\n\n")])])]),s("p",[n._v("虚方法与抽象类的区别：")]),n._v(" "),s("p",[n._v("（1）抽象方法必须在抽象类中，而虚方法不用。")]),n._v(" "),s("p",[n._v("（2）抽象方法在父类中不能实现，而虚方法可以实现。")]),n._v(" "),s("p",[n._v("（3）抽象方法在非抽象子类中必须实现（至少一个子类要实现，否则，没意义），而虚方法不用（虚方法可以使用父类自身的方法）。")]),n._v(" "),s("h2",{attrs:{id:"csharp基础·接口"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#csharp基础·接口"}},[n._v("#")]),n._v(" CSharp基础·接口")]),n._v(" "),s("p",[n._v("接口的格式可以记成用interface替换Class来定义（interface接口默认的访问修饰符是internal），如 ：public interface A { }")]),n._v(" "),s("p",[n._v("在接口中定义方法：")]),n._v(" "),s("p",[n._v("1、不能给方法和属性 添加访问修饰符，默认都是public。")]),n._v(" "),s("p",[n._v("2、接口中可以包含方法和属性，不能包含字段。")]),n._v(" "),s("p",[n._v("3、在接口中的方法/属性不能实现，如：")]),n._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("public interface A{\n    void Eat();  //这里是定义一个方法\n    float Prise { get ; set; } //这里是定义一个属性\n}\n")])])]),s("p",[n._v("4、一旦某个类实现了接口，就必须实现接口中定义的全部成员。")]),n._v(" "),s("p",[n._v("5、不能直接实例化接口，可以使用接口实现多态。")]),n._v(" "),s("p",[n._v("6、接口可以继承接口，但是调用的类必须实现所有方法。")]),n._v(" "),s("p",[n._v("7、显示实现接口，用于区分类中出现的接口方法和类的方法。")]),n._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v('#接口实例\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace _接口案例\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            IFly[] flys = { new MaBird(), new YingWu(), new Plane() };\n            for(int i = 0; i < flys.Length;i++)\n            {\n                flys[i].Fly();\n            }\n            Console.ReadKey();\n        }\n    }\n    class Bird\n    {\n        public void CHLSS()\n        {\n            Console.WriteLine("鸟都会吃喝拉撒睡");\n        }\n    }\n    interface IFly\n    {\n        void Fly();\n    }\n    class MaBird : Bird, IFly\n    {\n        public void Fly()\n        {\n            Console.WriteLine("麻雀会飞");\n        }\n    }\n    class YingWu : Bird, IFly\n    {\n        public void Fly()\n        {\n            Console.WriteLine("鹦鹉也会飞");\n        }\n    }\n    class QQ:Bird\n    {\n\n    }\n    class Plane:IFly\n    {\n        public void Fly()\n        {\n            Console.WriteLine("飞机会飞");\n        }\n    }\n}\n\n')])])]),s("p",[n._v("参考文献：")]),n._v(" "),s("p",[n._v("·https://www.jianshu.com/p/43da53f19ba3")])])}),[],!1,null,null,null);e.default=i.exports}}]);